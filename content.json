{"pages":[{},{},{}],"posts":[{"title":"个人学术成果总结","date":"2022-05-12T13:43:34.019Z","path":"2022/05/12/2022-05-12-个人学术成果总结/","text":"硕士期间，主要的研究工作，为RTP中的时间隐通道构建方法，论文列表如下： 硕士学位论文《基于主动丢包的VoLTE时间隐通道构建方法研究》 论文latex源码：https://github.com/XintingXu/master-degree-paper 论文实验代码源码：https://github.com/XintingXu/master-degree-code 论文pdf：https://github.com/XintingXu/master-degree-paper/releases/download/v2.0.2/thesis.pdf 学术论文《A robust packet‐dropping covert channel for mobile intelligent terminals》 发表时间：2022年3月 发表期刊：International Journal of Intelligent Systems 网页链接：https://onlinelibrary.wiley.com/doi/abs/10.1002/int.22868 学术论文《An end-to-end covert channel via packet dropout for mobile networks》 发表时间：2018年5月 发表期刊：International Journal of Distributed Sensor Networks 网页链接：https://journals.sagepub.com/doi/full/10.1177/1550147718779568 学术论文《A robust packet-dropout covert channel over wireless networks》 发表时间：2020年6月 发表期刊：IEEE Wireless Communications 网页链接：https://ieeexplore.ieee.org/abstract/document/9116089/ 发明专利《一种基于主动丢包的时间隐通道鲁棒构建方法》 申请号：201910648138.5","tags":[{"name":"时间隐通道","slug":"时间隐通道","permalink":"http://www.xuxinting.cn/tags/%E6%97%B6%E9%97%B4%E9%9A%90%E9%80%9A%E9%81%93/"}]},{"title":"ARM体系结构之TCM","date":"2020-12-20T13:40:00.000Z","path":"2020/12/20/2020-12-20-arm-TCM/","text":"Tightly-Coupled MemoryTCM(Tightly-Coupled Memory)，紧耦合内存，位于SOC内部的片上存储区域，具有极低的访问延迟。类似于Cache，TCM也分为L1TCM和L2TCM。根据存储对象，TCM通常也分为ITMC和DTCM。在使用上，TCM与RAM具有相似的特征。 TCM适用对象TCM is used for a few things: FIQ and other interrupt handlers that need deterministictiming and cannot wait for cache misses. Idle loops where all external RAM is set to self-refreshretention mode, so only on-chip RAM is accessible bythe CPU and then we hang inside ITCM waiting for aninterrupt. Other operations which implies shutting off or reconfiguringthe external RAM controller. TCM适用于以下场景： 快速中断，或其它不能接受Cache miss或需要确定执行时间的中断处理程序 当芯片进入低功耗模式时，RAM进入自刷新模式不可访问，只有TCM可以访问，IDLE进程需要在TCM中运行等待中断 其他需要在RAM不可访问阶段执行的程序","tags":[{"name":"C","slug":"c","permalink":"http://www.xuxinting.cn/tags/c/"},{"name":"arm","slug":"arm","permalink":"http://www.xuxinting.cn/tags/arm/"}]},{"title":"Linux Kernel之randomized layout","date":"2020-12-20T12:10:00.000Z","path":"2020/12/20/2020-12-20-kernel-randomize-layout/","text":"randomized layout在Linux Kernel的结构体声明中，经常会看见最后带了一个__randomize_layout标识。初次学习，对其机制不太了解，并且网上对其展开描述的内容也不是很多，只有一些英文文档中有介绍。因此，本博客里记录下学习的成果。 结构体随机化不管是地址随机化，还是结构体随机化，其目的都是增强内核安全性。结构体随机化也是GCC编译器的一个重要特性，使能后将在编译时随机排布结构体中元素的顺序，从而使攻击者无法通过地址偏移进行攻击。（存疑，虽然运行时的结构排布与源码可能不一致，但通过结构元素的地址，仍然可以推断出排布形势，只能防范非自适应的攻击，是否可以这样理解？） 结构体随机化在编译时根据随机数种子打乱排布顺序，但一旦编译完成，结构体内容即确定。（存疑，既然编译时即确定，那么公开发行的二进制版本是可以被反向的，该保护机制是否还有效？以及，调试时，我们能否看到真实的结构体顺序?） 在Linux Kernel中，结构体中存在函数指针的部分是攻击者重点关注的对象。因此，只存储函数指针的结构体，是默认开启结构体随机化的，如果不需要，需要添加__no_randomize_layout进行排除。另一方面，如果特定结构体希望主动开启保护，需要添加__randomize_layout标识。 结构体随机化后的差异 既然已经开启了结构体随机化，在进行赋值或初始化时，就需要按照元素名称进行赋值，否则会出现非预期结果。（designated initializers） 不要对开启了随机化的结构体指针或对象进行强制数据转换，因为内存排布是不可预测的。 涉及到远程调用的结构体，如果需要保证结构体内容的一致性，需要添加例外。 调试时，根据dump推算结构体内容将极为麻烦，因为每个版本、每个平台的布局都将不同。 部分以模块形式添加到Kernel中的驱动，为保持结构体一致性，在编译时需要采用与kernel相同的随机数种子，这带来了极大的安全风险。","tags":[{"name":"C","slug":"c","permalink":"http://www.xuxinting.cn/tags/c/"},{"name":"kernel","slug":"kernel","permalink":"http://www.xuxinting.cn/tags/kernel/"}]},{"title":"Leetcode-459 Repeated Substring Pattern","date":"2020-06-02T09:00:00.000Z","path":"2020/06/02/2020-06-02-Leetcode-459/","text":"459 Repeated Substring Pattern判断字符串是否为子串重复构成，输入字符串的长度在10000内。 例如，’abab’由’ab’循环两次构成，’aa’由’a’循环两次构成。 1. 解决思路1.1 双指针双指针是最直接的方式，固定头指针的位置，移动尾指针，知道找到一个重复的子串，然后对剩余的部分进行子串验证。 如果字符串是由子串重复生成的，则一定存在一个最小子串。例如，’aaaa’由’aa’重复两次构成，同时也是’a’重复四次构成。但’aa’是’a’重复两次构成的，因此，识别出最小子串’a’即可。 双指针法的时间复杂度为O(n2)，空间复杂度为O(1)。 bool repeatedSubstringPattern(char *s){ if (s == NULL) { return false; } bool result = false; char *begin = s; char *end = s + 1; while (*end != 0) { while (*end != 0 &amp;&amp; *begin != *end) { ++ end; } if (*end == 0) { break; } char *temp_end = end; char *temp_begin = begin; while (*temp_end != 0 &amp;&amp; *temp_begin == *temp_end) { ++ temp_begin; ++ temp_end; } if (*temp_end == 0 &amp;&amp; (temp_end - end) % (end - begin) == 0) { result = true; break; } ++ end; } return result; } 1.2 掐头去尾假设一个字符串有子串重复构成，则第一个字符一定是子串的首字符，同时最后一个字符为子串的尾字符。 所谓掐头去尾，分别包括掐头和去尾两步。如果字符串由子串重复构成，则字符串中的子串至少出现一次，掐头则破坏了第一个子串，去尾则破坏了最后一个子串。将掐头及去尾的结果拼接，如果中间的部分与原字符串一致，则意味着符合重复条件。 例如，’abcabcabc’由’abc’重复三次构成，掐头后剩余’bcabcabc’，去尾后剩余’abcabcab’，拼接得到’bcabcabcabcabcab’，重复的结果只剩下四次。在’bcabcabcabcabcab’中搜索’abcabcabc’，如果匹配，则证明符合重复规则。 如果S由一系列子串构成，即S1 S2 S3 … Si … Sn。如果S由子串重复构成，则S1 &#x3D; S2 &#x3D; S3 &#x3D; Si &#x3D; Sn。掐头即破坏S1，去尾即破坏Sn，拼接后的构成为S2 S3 … Si … Sn S1 S2 S3 … Si … Sn-1。当拼接结果中仍然存在S，则满足S2 &#x3D; S1，S3 &#x3D; S2，Si + 1 &#x3D; Si，Sn &#x3D; Sn - 1，Sn &#x3D; S1，汇总即S1 &#x3D; S2 &#x3D; S3 &#x3D; Si &#x3D; Sn。 掐头去尾的时间复杂度为O(n)，空间复杂度为O(n)。 bool repeatedSubstringPattern(char *s){ if (s == NULL) { return false; } bool result = false; int s_len = strlen(s); char *s_s = (char *)malloc(sizeof(char) * s_len * 2 - 2); memcpy_s(s_s, s_len * 2 - 2, s + 1, s_len - 1); memcpy_s(s_s + s_len - 1, s_len - 1, s, s_len - 1); for (int index = 0 ; index &lt;= s_len - 2 ; ++ index) { if (*s == *(s_s + index) &amp;&amp; memcmp(s, s_s + index, s_len) == 0) { result = true; break; } } free(s_s); return result; }","tags":[{"name":"C","slug":"c","permalink":"http://www.xuxinting.cn/tags/c/"},{"name":"Leetcode","slug":"leetcode","permalink":"http://www.xuxinting.cn/tags/leetcode/"}]},{"title":"Leetcode-463 Island Perimeter","date":"2020-06-02T09:00:00.000Z","path":"2020/06/02/2020-06-02-Leetcode-463/","text":"463 Island Perimeter给出岛屿地图，求解岛屿的周长。岛屿可能有多个块组成，所有的块连接成为一个大岛。 [0,1,0,0] [1,1,1,0] [0,1,0,0] [1,1,0,0] 1. 解决思路1.1 两次遍历根据岛屿的特征，只有出现0-1跳变的位置才存在边界，因此按照行序、列序进行两次遍历，对所有的跳变位置进行统计，即可得到最终的周长。 该方法的时间复杂度为O(n2)，空间复杂度为O(1)，但进行列序遍历时，由于Cache命中的问题，效率较低。 int islandPerimeter(int** grid, int gridSize, int* gridColSize){ if (grid == NULL || gridColSize == NULL || gridSize == 0) { return 0; } int result = 0; // for vertical borders for (int row = 0 ; row &lt; gridSize ; ++ row) { if (**(grid + row) == 1) { ++ result; } for (int col = 0 ; col &lt; *(gridColSize + row) - 1 ; ++ col) { if (*(*(grid + row) + col) != *(*(grid + row) + col + 1)) { ++ result; } } if (*(*(grid + row) + *(gridColSize + row) - 1) == 1) { ++ result; } } // for horizontal borders for (int col = 0 ; col &lt; *gridColSize ; ++ col) { if (*(*grid + col) == 1) { ++ result; } for (int row = 0 ; row &lt; gridSize - 1; ++ row) { if (*(*(grid + row) + col) != *(*(grid + row + 1) + col)) { ++ result; } } if (*(*(grid + gridSize - 1) + col) == 1) { ++ result; } } return result; } 1.2 关联遍历对于单个位置来说，当没有相邻陆地时，存在4条边界。每存在一个相邻陆地，则两个陆地各减少一条边界。因此，遍历过程中，对相邻情况进行判断。按照左上角到右下角的顺序，判断是否为陆地。如果为陆地，则其右侧及下方是否为陆地。两者分别统计，得到的陆地数*4，减去相邻数*2，即为最终的边界周长。 该方法的时间复杂度为O(n2)，空间复杂度为O(1)，但遍历中Cache效率较低。 int islandPerimeter(int** grid, int gridSize, int* gridColSize){ if (grid == NULL || gridColSize == NULL || gridSize == 0) { return 0; } int result = 0; int inside = 0; for (int row = 0 ; row &lt; gridSize ; ++ row) { for (int col = 0 ; col &lt; *(gridColSize + row) ; ++ col) { if (*(*(grid + row) + col) == 1) { ++ result; if (col &lt; *(gridColSize + row) - 1 &amp;&amp; *(*(grid + row) + col + 1) == 1) { ++ inside; } if (row &lt; gridSize - 1 &amp;&amp; *(*(grid + row + 1) + col) == 1) { ++ inside; } } } } result = result * 4 - inside * 2; return result; }","tags":[{"name":"C","slug":"c","permalink":"http://www.xuxinting.cn/tags/c/"},{"name":"Leetcode","slug":"leetcode","permalink":"http://www.xuxinting.cn/tags/leetcode/"}]},{"title":"25岁，与命运对赌","date":"2020-05-28T14:16:00.000Z","path":"2020/05/28/2020-05-28-25岁，与命运对赌/","text":"又到了毕业季提交了盲审的论文，交代完手头上的事情，突然间感觉心里空落落的。 三年前的这个时候，在本科毕业前夕，告别了熟悉的实验室，选择了一条模糊的道路。现在看来，当时的选择也算不上是错误，其实有没有后悔只有自己知道。对于我来说，其实还是比较希望稳定的生活，在熟悉的导师、熟悉的实验室读研，无疑能够避免很多麻烦。在那一两个月里，我也曾后悔，总觉得是不是自己太匆忙了。 到了现在，想明白，其实变化才是正常的人生。没有人能够保证，自己的舒适区能够永恒。青蛙不是被煮死的，而是在准备跳出来的时候发现为时已晚。 终于要告别校园在北理工待了七年，过去的25年里，这是我就读时间最长的学校。18岁到24岁的美好时光，全部留在了良乡和魏公村。七年了，我已经熟悉了周围的点滴。 如果当时选择转博，在北理工的时间还能加几年。但然后呢，我还舍得离开吗，我还敢做出改变吗？在人生的路途上，没有不变的风景，只有不变的脚步。 也许在最终离开的时刻，证明了自己还是有能力的。但自己也明白，真的有很大差异吗？其实只不过是将其余的时间与精力，转换到日常的学习中，用刷题的方式积累出来的。 未来，向何方最近，大概瞄了一眼大家的就业情况，发现国企事业单位和银行的比例还是蛮高的。也许和性格有关，最近才明白自己一直在压抑自己，并且属于缺爱的人格。所以，在做事风格上有独行侠味道，并且对自己特别狠，宽以待人严于律己。 这样的结果，是基本上不再依赖他人，和外界划出了一条清晰的界限。好处呢，是对自己人生的决策权，所有决定的好坏一人承担。既然看开了，无所谓对谁负责，最后是一无所有，还是卑微苟且，也不过如此嘛。 想在想想，也挺好笑的，曾经有一个主动活泼的姑娘，她大胆主动地来到我的身边，却被我的冷淡伤害。也许那曾经是改变的好时机，可是，错过了也只能错过。真的值得被爱吗，也无所谓了，太好的爱情被辜负也是大概率事情。既然这样，未来怎么走，有什么关系吗，不管生死，不管沉浮，没有后顾之忧，没有舍不得的那个人。 后记稀里糊涂写了很多，有些想法也没表达出来，多少也算个留念吧。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.xuxinting.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"910实验室服务器配置-LXC容器中时区设置","date":"2018-06-22T18:30:09.833Z","path":"2018/06/23/2018-06-23-910实验室服务器配置-LXC容器中时区设置/","text":"在LXC容器中进行时区的设置虽然LXC容器在使用上和物理机没有区别，但是因为缺少安装过程中的配置操作，在一些配置上会出现问题。 比如时区的问题，虽然容器中的时间和宿主机的时间是对应的，但是容器中的默认时区为空，导致时间转换上存在不一致的问题。以我们为例，宿主机上的时间是CST，也就是东八区时间；但是容器中默认为UTC+0时区，所以会有8小时的时差。 解决方案在容器中进行时区配置之前试过导入时区等方式，但效果不太好。 最近发现有一个比较方便的方法，可以直接将时区修改为目标时区。 1sudo dpkg-reconfigure tzdata 在LXC容器中运行上面的命令，根据出现的辅助界面，选择Asian-&gt;Shanghai，即可完成时区的更改。 通过这种方式，即使容器和宿主机进行了重启，仍然可以确保时区的配置是有效的。","tags":[{"name":"910实验室服务器","slug":"910实验室服务器","permalink":"http://www.xuxinting.cn/tags/910%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"23岁，新的开始","date":"2018-05-23T02:04:53.000Z","path":"2018/05/23/2018-05-23-23岁，新的开始/","text":"23岁，新的开始 2018年5月23日，夏初时节的普通一天，北京的天气甚至有点儿凉意。 去年的今天，还在为毕业论文奋笔疾书，甚至压力已经大到无法在早上安然入睡。 5年前的今天，即将接受高考的洗礼，等待的是未知的结果，是无限的可能。 2018年的今天，开始学习新的方向，即将迎接最具有挑战性的一次团队合作。 2018年的今天，结束了自己人生中第一篇学术成果的发表过程，中间虽有波澜，好在万事顺利。 2018年的今天，硕士生涯的1&#x2F;3即将度过，剩下的时日不多，没有时间可以浑浑噩噩。 离开家的日子过完18岁的生日，结束高考的煎熬，惊险来到北京理工大学。从那以后，便没有了过生日的习惯。还没离开家乡的时候，自己怎么都是个孩子，即使体型和年龄都已经不再是孩子。但是，在父母的眼中，不管年纪多大，永远是曾经的那个小孩子。 可是，当离开了父母的庇护，来到广阔的空间，有一大把的事情需要自己决断。即使有委屈，即使不顺利，也要自己含泪坚持。总有一天，所有的事情都依靠自己；总有一天，父母也会离去；总有一天，自己也会成为父母。 没有时间等待享受慢时光，享受惬意的人生，真的是一种非常令人向往的生活。也许有一天，心也累了，精力也不够了，过着茅舍、耕耘、犬吠、鸡鸣的生活，是一种最好的归宿。但对于我们一代人来说，在出生的那一刻，就已经具备了非常大的差距。90后的一代已经错过了资本发展最繁荣的时期，等待我们的是阶级的逐渐固化。当大城市已经被前辈们挤满，后来的我们如何在强者之间找到自己的立足之地？ 我见过很多同学，在本科阶段的成绩还非常不错，但是到了硕士阶段却沉迷游戏，荒废科研。这种状态好吗？在二十多岁，脑力和精力最充沛的年龄，在接受多年专业教育后具备基本技能的时候，仍然以混学历的想法度过这几年，这样的青春真的是喂了狗了。 坚持下去每天比别人多付出一点，其实很痛苦，当他们可以娱乐休息，可以天南海北的时候，自己却要不断的学习新的内容。羡慕吗？会的。别人会羡慕吗？不确定。让自己的每一天都过得充实，每天都前进一点儿，虽然很累，虽然很痛苦，虽然很受伤。 但我希望，在40岁的时候，不后悔自己20多岁的这几年。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.xuxinting.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Linux服务器更换硬件后网卡无法识别解决","date":"2018-03-03T04:49:20.159Z","path":"2018/03/03/2018-03-03-Linux服务器更换硬件后网卡无法识别解决/","text":"Linux服务器更换硬件后网卡无法识别解决问题描述最小化安装的Linux服务器进行硬件修改后，再重启出现硬件无法识别的问题，即原始配置中的eth0或enpxsx无法加载。 通过查阅相关资料，发现是网卡的标识出现了改变，导致原来的配置无法识别。 解决方法检索最新的网卡编号，然后在配置文件中进行更新，重启网络服务，即可重新加载网络。 操作步骤检索更新后的网卡信息 1ip link 显示的结果中，除了本地回环地址lo，还包含更新后的网卡名称，例如“enpxsx” 更改网卡配置在网卡配置文件 &#x2F;etc&#x2F;networking&#x2F;interface 中更新网卡名称 重启网络服务 1sudo /etc/init.d/networking restart 执行结束后，应该就可以连接网络了","tags":[{"name":"Linux","slug":"linux","permalink":"http://www.xuxinting.cn/tags/linux/"},{"name":"Network Interface","slug":"network-interface","permalink":"http://www.xuxinting.cn/tags/network-interface/"}]},{"title":"910实验室服务器配置-LXC容器复制","date":"2017-12-19T02:29:08.201Z","path":"2017/12/19/2017-12-19-910实验室服务器配置-LXC容器复制/","text":"为减少容器的配置工作，为用户创建自己的容器之前，预先配置好了一个模板容器。其他用户的容器可以基于该模板进行创建。 在我们的配置中，有一个特殊点，就是容器中的&#x2F;home目录，与~&#x2F;SSD目录，是单独存储的。并且在LXC的配置测试中，发现如果在宿主机中进行其它mount操作，将导致LXC容器无法启动。所以，对以上涉及的几个目录，需要逐步修改config，并在容器内进行相应配置。 正常启动容器首先取消容器内的所有挂载，然后正常启动容器。如果容器正常启动，则证明容器的内容没有基本错误。 修改容器的主机名修改容器的rootfs&#x2F;etc&#x2F;hostname，修改继承的主机名。 同时修改容器的config文件中，lxc.utsname，改为与hostname同样的主机名。 重启容器，检查修改是否有效。 挂载home目录停止容器，将rootfs&#x2F;home&#x2F; 下的全部文件移到设定的挂载目录。 修改config配置文件，添加对应的lxc.mount.entry配置，例如 1lxc.mount.entry = /mnt/HDD/XXXX home none bind 0 0 并且，将&#x2F;mnt&#x2F;HDD&#x2F;XXXX&#x2F;下的所有目录添加读、写、执行权限。 启动容器，检查是否正常。 新建用户及用户目录启动容器后，attach到容器内，以root身份创建用户 1useradd -m -s /bin/bash XXXX 添加新用户XXXX，并创建其用户目录。 在&#x2F;mnt&#x2F;HDD&#x2F;XXXX&#x2F;中，给新创建的用户目录赋予7777权限。 登录到新创建的用户，创建一个用于挂载其他路径的目录，在我们的使用中，新的挂载点是SSD。 将其他目录挂载在新用户关闭容器。 更改容器的config文件，添加新的mount配置 1lxc.mount.entry = /mnt/SSD/XXXX home/XXXX/SSD none bind 0 0 现在重新启动容器，检查挂载是否成功。 总结经过以上几步，不仅将容器中的&#x2F;home目录转移到其它的可靠位置，也在用户目录下新添加了一个其他的挂载点，在使用中具有更好的效果。","tags":[{"name":"实验室服务器搭建","slug":"实验室服务器搭建","permalink":"http://www.xuxinting.cn/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"910实验室服务器搭建-LXC独立IP配置","date":"2017-12-17T11:39:37.000Z","path":"2017/12/17/2017-12-17-910实验室服务器搭建-LXC独立IP配置/","text":"LXC容器的默认IP，是通过网桥”lxcbr0”分配的10.0.3.XXX的局域网IP，除了host主机外，其他用户无法访问。 解决方案可以通过端口映射，或者更换网桥的方法，将容器和host置于同一个网段，使得外部用户也可以登入容器内部。 因为我们涉及的用户比较多，采用端口映射的方法不仅麻烦，还给使用人员带来不便。 独立IP设置添加网桥通过ifconfig，查看当前的网络信息，不同的环境有不同的命名，但一般有一个外网接口enXX、一个本地回环l0、一个LXC容器的默认网桥lxcbr0。 我们需要实现的，是创建一个网桥，使得LXC容器能够分享本机网卡。 修改”&#x2F;etc&#x2F;networking&#x2F;interfaces”添加 1234567auto br0iface br0 inet dhcp bridge-ifaces XXX bridge-ports XXX up ifconfig XXX upiface XXX inet manual 其中”XXX”即为原有的网络接口名称。 修改完毕后，重启系统。 如果没有问题的话，可以再次通过ifconfig查看当前的网络状况，网桥br0应该配好了。 修改LXC配置文件修改”&#x2F;etc&#x2F;lxcf&#x2F;default.conf”，以及现有容器的配置文件。 将原有的项目修改为： 1lxc.network.link = br0 其中”br0”即为上一步创建的网桥名称，如果命名为其他，此处也应该对应修改。 检查结果以上操作完成后，在容器内查看到的IP地址，应该就是和主机同网段的IP。这样，宿主机所在网络的其他用户，也可以访问容器了。","tags":[{"name":"实验室服务器搭建","slug":"实验室服务器搭建","permalink":"http://www.xuxinting.cn/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"910实验室服务器配置-非特权LXC容器","date":"2017-12-17T11:08:39.000Z","path":"2017/12/17/2017-12-17-910实验室服务器配置-非特权LXC容器/","text":"创建非特权LXC容器对于特权容器来说，虽然创建过程比较方便，但存在进程权限的问题，隐形容器的安全性。为了确保服务器用户的误操作不会导致服务器崩溃，经过实验，决定使用非特权容器来进行隔离。 非特权LXC对于非特权的LXC容器来说，容器中实际执行的0号用户ID，并不对应服务器的0号用户ID，从而确保服务器上的内容不会出现问题。 LXC采用uid映射的方法，将容器中的UID映射到非特权服务器用户的UID空间。 因为服务器需要挂载一些设备，而只有服务器真实的特权用户可以对设备进行操作，容器内的用户是无法完成这一操作的。 检查现有的UID&#x2F;GID映射表通过检查 &#x2F;etc&#x2F;subuid 及 &#x2F;etc&#x2F;subgid ，得到映射范围。 默认的映射规则为，对于第一个用户 12uid:100000:65536gid:100000:65536 设定网卡上限设置LXC的配置文件 &#x2F;etc&#x2F;lxc&#x2F;lxc-usernet 添加类似于”user_name veth lxcbr0 XX” 的记录，即可将用户”user_name”通过网桥”lxcbr0”创建虚拟网卡的最大数量，限定为”XX” 修改LXC配置以上工作完成后，需要进行配置文件的修改。 检查文件夹如果目录 “&#x2F;.config&#x2F;lxc”和”&#x2F;.local&#x2F;share&#x2F;lxc”如果不存在，执行下面两条命令，创建目录 12mkdir -p ~/.config/lxcmkdir -p ~/.local/share/lxc 其中，”&#x2F;.local&#x2F;share&#x2F;lxc”即为创建好的容器存储位置，”&#x2F;.config&#x2F;lxc”是容器的配置文件存储位置。 设定配置文件将LXC的默认配置文件 “&#x2F;etc&#x2F;lxc&#x2F;default.conf” 复制到 “~&#x2F;.config&#x2F;lxc&#x2F;default.conf” 并在最后添加两条配置 12lxc.id_map = u 0 100000 65536lxc.id_map = g 0 100000 65536 需要注意的是，配置中的数字，均应和subuid及sungid对应起来，否则会出现错误。 重启或重新登陆配置完以上内容后，建议重启，或者重新登陆，确保配置生效。 创建并配置容器创建容器对于非特权容器，默认类型必须是”download” 1lxc-create -t download -n XXXX -- --server mirrors6.tuna.tsinghua.edu.cn/lxc-images 新创建的LXC容器名即为”XXXX”,通过清华大学的IPv6镜像服务器下载。 创建过程中，可以选择操作系统类型、版本、架构 配置容器首先开启容器 1lxc-start -n XXXX -d -d表示以后台模式运行，”XXXX”即为创建的容器名 之后可以查看容器的状态 1lxc-info -n XXXX 如果查看结果显示容器正在运行，说明配置及安装正确。 ** 需要注意的是，非特权容器的用户密码并未设定 **需要由宿主机进行设定 1lxc-attach -n XXXX 即可以root身份登入到”XXXX”容器中 然后就可以给默认用户设置密码、更改用户权限，LXC容器内的用户即可执行sudo等权限。","tags":[{"name":"实验室服务器搭建","slug":"实验室服务器搭建","permalink":"http://www.xuxinting.cn/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"910实验室服务器搭建-LXC虚拟化","date":"2017-12-16T07:25:22.000Z","path":"2017/12/16/2017-12-16-910实验室服务器搭建-LXC虚拟化/","text":"根据实验室的任务需要，该服务器需要同时运行多种任务，且任务间的干扰大。为了能够将不同开发人员的环境区分开，我们在经过多种尝试后，决定采用LXC容器进行虚拟化。 虚拟化需求 各容器应当具有独立IP 容器内具备运行CUDA环境的能力 性能损耗小 管理方便 LXC思路因为现有的服务器资源比较充裕，所以给用户空间和编译执行空间设定了不同的RAID卷，用户空间单独提出进行挂载，这样，每个用户的数据都能安全保存。每个用户对应独立IP的容器，容器内具有root权限，可以执行任意的操作。 通过LVM对根目录扩充，容许用户在容器中进行大磁盘占用的操作。独立的RAID0 SSD，支持用户将当前的执行任务放入其中，进行当前运行。独立的RAID1 HDD，支持用户存储用户目录内容，且数据安全有保证。 LXC容器创建创建模板容器首先创建一个模板容器，并将网络、ssh-server等内容配置好，之后给用户配置的容器都基于该模板容器进行复制。 1lxc-copy -n old_name -N new_name -K old_name 是模板容器名，new_name 是目标容器名,-K表示保存之前的配置。 修改容器内的特定信息进入到复制得到的容器rootfs，更改容器内的&#x2F;etc&#x2F;hostname，将其更改为需要的名称，否则会显示模板的主机名。 修改容器的配置文件config，将文件夹的挂载配置修改为对应的目录。 由宿主机的lxc-attach，进入容器中，创建用户，并赋予sudo权限，用户名与挂载的目录一致。 实现效果最终实现的效果，是用户可以通过独立IP登陆到容器中，并且可以使用挂载的设备与目录。 用户可以自行配置UI，通过vncserver进行访问；也可以创建ftp服务器，直接进行文件传输。 从实际使用效果来看，创建的各个容器就像虚拟机一样，有自己独立的空间，也有独立的IP可以直接访问。 因为创建的容器运行在用户态，在容器中即使以root身份执行，对应于实际机器中的进程ID也不是真正的root。 容器相对于虚拟机来说，资源占用小得多，并且可以根据实际需要进行释放，大大缓解宿主机的压力。","tags":[{"name":"实验室服务器搭建","slug":"实验室服务器搭建","permalink":"http://www.xuxinting.cn/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"910实验室服务器RAID搭建","date":"2017-12-16T06:03:43.000Z","path":"2017/12/16/2017-12-16-910实验室服务器RAID搭建/","text":"实验室服务器RAID卷创建记录创建SSD RAID0待创建的SSD 为sde与sdf使用mdadm工具创建卷 查看待加入的磁盘挂载情况1lsblk -o NAME,SIZE,FSTYPE,TYPE,MOUNTPOINT 创建数组1sudo mdadm --create --verbose /dev/md0 --level=0 --raid-devices=2 /dev/sde /dev/sdf 创建后将清空原有的磁盘分区表，根据提示输入y，即可完成。 查看创建结果1cat /proc/mdstat 根据输出的情况查看RAID版本，以及加入的磁盘是否正确。 创建并安装文件系统1. 1sudo mkfs.ext4 -F /dev/md0 根据创建的RAID卷号，修改md后的序号，即可在卷上创建ext4文件系统 2. 1sudo mkdir -p /mnt/SSD 创建挂载点 3. 1sudo mount /dev/md0 /mnt/SSD 挂载创建好的卷 配置自启动1. 1#### sudo mdadm --detail --scan | sudo tee -a /etc/mdadm/mdadm.conf 保存生成的磁盘阵列 此命令执行一次就好，否则会在&#x2F;etc&#x2F;mdadm&#x2F;mdadm.conf出现重复项2. 1sudo update-initramfs -u 更新initramfs或初始RAM文件系统，以便阵列在早期引导过程中可用 3. 1echo &apos;/dev/md0 /mnt/SSD ext4 defaults,nofail,discard 0 0&apos; | sudo tee -a /etc/fstab 添加开机挂载选项 针对SSD的RAID0创建完毕 创建HDD的RAID1待创建的HDD为sdg和sdh使用mdam创建冗余阵列 创建RAID阵列1sudo mdadm --create --verbose /dev/md1 --level=1 --raid-devices=2 /dev/sdg /dev/sdh 创建的结果添加到 &#x2F;dev&#x2F;md1 **创建结束后，一定要通过命令 1cat /proc/mdstat 查看当前的进展，当同步进度为100%时，才可进行后续操作！！！！** 创建文件系统并挂载1. 1sudo mkfs.ext4 -F /dev/md1 在RAID上创建文件系统 2. 1sudo mkdir -p /mnt/HDD 创建挂载点，命名为HDD 3. 1sudo mount /dev/m1 /mnt/HDD 挂载到挂载点 4. 1sudo mdadm --detail --scan | sudo tee -a /etc/mdadm/mdadm.conf 保存RAID布局 5. 1sudo update-initramfs -u 更新initramfs或初始RAM文件系统，以便阵列在早期引导过程中可用 6. 1echo &apos;/dev/md1 /mnt/HDD ext4 defaults,nofail,discard 0 0&apos; | sudo tee -a /etc/fstab 更新fstab，开机自动挂载 所有过程执行完毕","tags":[{"name":"实验室服务器搭建","slug":"实验室服务器搭建","permalink":"http://www.xuxinting.cn/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"910实验室服务器搭建记录","date":"2017-12-15T20:18:06.020Z","path":"2017/12/16/2017-12-16-910实验室服务器搭建记录/","text":"近期实验室的服务器进行升级优化，在此记录安装过程，作为备忘。 硬盘配置硬盘资源现有硬盘资源情况如下，包含SSD及HDD复合资源。 4TB HDD SATA 2块 240GB SSD SATA 5块 240GB SSD M.2 1块 硬盘设置计划根据现有资源，主要划分为三部分：第一部分，系统空间，作为宿主机文件存储及其他虚拟机空间；第二部分，用户主目录，挂载为用户的&#x2F;home目录；第三部分，执行空间，作为当下任务的执行空间。 240GB M.2 SSD x1 + 240GB SATA SSD x3 &#x3D; 861GB 可用空间，作为服务器系统空间 240GB SATA SSD x2 RAID0 &#x3D; 480GB 可用空间，作为当前任务的执行空间，挂载到用户目录下 4TB SATA HDD x2 RAID1 &#x3D; 4TB可用空间，作为用户目录的挂载空间，用户目录直接分离出来","tags":[{"name":"实验室服务器搭建","slug":"实验室服务器搭建","permalink":"http://www.xuxinting.cn/tags/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"}]},{"title":"读研第一周-感触","date":"2017-09-20T06:29:08.187Z","path":"2017/09/20/2017-09-20-读研第一周-感触/","text":"2017年，从北京理工大学毕业，2017年，在北京理工大学入学，一段新的开始。 结束2017年6月30日晚上，也是这所学校通知我们的离开时间，趁着离开前的一个多小时，走了一遍曾经走过的地方。 看着曾经生活过的13#606房间的灯不再亮起，和师兄谈论曾经考研奋斗过的地方，去图书馆看看曾经的精神居所。 一切都不会重来 开始2017年9月18日，硕士生涯的第一堂课，见到了曾经的兄弟，见到了曾经的老师。 可是，已经不是熟悉的教室，已经不是熟悉的人群。 但却没有了本科期间那种逍遥的感觉，手头上的数据还没处理完，论文还没开始写，压力一直都在。 曾经一节课晃晃悠悠便过去，如今强迫自己认真听课，每天的上课都是一个繁重的劳动。 希望过着自由的探索生涯，却发现不得不回到熟悉的听课-作业-复习-考试死循环。 我甚至有些理解去年这时候想不开的那个师兄，如果周围没有实验室同学的陪伴，如果没有熟悉的人一起上课，尤其是跳到北京理工大学这个曾经高不可及的平台，失落与孤单，将会彻底的摧毁一个人。 好在我还熟悉这个校园，好在我还有很多挚友，生活还是充满希望。 新的阶段，虽然难了点儿，加油！！！","tags":[{"name":"心情","slug":"心情","permalink":"http://www.xuxinting.cn/tags/%E5%BF%83%E6%83%85/"}]},{"title":"Python3 二进制字符串与int转换","date":"2017-09-11T23:03:47.562Z","path":"2017/09/12/2017-09-12-Python3-二进制字符串与int转换/","text":"Python3中，二进制字符串与int的转换最近的实验中需要用到int转二进制字符串，以及二进制字符串转int的操作，现整理出来，供后续查阅 int转二进制字符串int转二进制字符串，是最简单的，同时也是形式变化比较多的 带进制标识0b的转换 bin()函数 1234&gt;&gt;&gt; bin(3)&apos;0b11&apos;&gt;&gt;&gt; bin(-10)&apos;-0b1010&apos; 如果需要转换为其他进制，需要使用函数hex()或oct() format()函数 12&gt;&gt;&gt; format(14, &apos;#b&apos;)&apos;0b1110&apos; 如果需要转换为其他进制，只需要将’b’替换为’x’（16进制）或’o’（8进制） 不带进制表示的转换12&gt;&gt;&gt; format(14, &apos;b&apos;)&apos;1110&apos; 如果需要转换为其他进制，只需要将’b’替换为’x’（16进制）或’o’（8进制） 二进制字符串转int12&gt;&gt;&gt; int(&quot;1110&quot;,2)14 如果需要转换为其他进制，只需要将’2’替换为其他数值单位","tags":[{"name":"Python3","slug":"python3","permalink":"http://www.xuxinting.cn/tags/python3/"}]},{"title":"Windows添加网络打印机脚本","date":"2017-09-10T22:50:38.051Z","path":"2017/09/11/2017-09-11-Windows添加网络打印机脚本/","text":"Windows下通过脚本添加网络打印机最近在内网搭了一台打印服务器，需要给实验室的同学共享，但是添加打印机的操作太繁琐，所以编写了一个添加打印机的脚本，可以代替人工操作过程。 12345678@echo offecho 添加网络打印机echo 等待....net use \\\\&#123;IP&#125;\\IPC$ &quot;&#123;密码&#125;&quot; /user:&quot;&#123;用户名&#125;&quot;rundll32 printui.dll,PrintUIEntry /in /u /z /q /n &quot;\\\\&#123;IP&#125;\\&#123;打印机名&#125;&quot;rundll32 printui.dll,PrintUIEntry /y /n &quot;\\\\&#123;IP&#125;\\&#123;打印机名&#125;&quot;echo 打印机添加成功pause {IP}替换为打印机的IP {密码}替换为打印服务器的用户密码 {用户名}替换为打印服务器的用户名 {打印机名}替换为打印机的名称，可以在打印服务器中进行设置","tags":[{"name":"Windows","slug":"windows","permalink":"http://www.xuxinting.cn/tags/windows/"},{"name":"打印机","slug":"打印机","permalink":"http://www.xuxinting.cn/tags/%E6%89%93%E5%8D%B0%E6%9C%BA/"}]},{"title":"VoIP丢包模型与分析","date":"2017-08-30T11:37:50.000Z","path":"2017/08/30/2017-08-30-VoIP-TroubleShouter-burst-loss/","text":"前言本文根据VoIP Troubleshooter|Indepth: Packet Loss Burstiness总结，文章中的数据和结论非本人原创。 VoIP丢包IP的丢包以突发性丢包为主，但是对于常见的几种丢包模型，存在一些不同层次的误解。本文描述了几种常见的丢包模型，并分析了其拟合度。 伯努利模型(独立模型)简单的独立丢包模型，是最常用的一种。在这种模型中，每一个数据包（或比特错误）的发生，都有着固定的概率Pe。对于一个很大规模的数据包数量N，预期的丢包数量是N*Pe，丢包率Pe &#x3D; 丢包数量&#x2F;总的传输包数。 Gilbert和Gilbert-Elliott模型最著名的突发丢包模型的是Gilbert模型，及其变种Gilbert-Elliott模型。这两种都是二态模型，从好到坏或者从0到1的的转换，分别是P01或者P11. Gilbert模型 状态0是一个0丢失&#x2F;错误 状态1是一个具有独立丢包率Pe1的有损状态 Gilbert-Elliott模型 状态0是一个具有独立丢包概率Pe0的低丢包状态 状态1是一个具有独立丢包概率Pe1的有损状态 一般情况下，Gilbert模型中的有损状态对应一个“丢包”状态。例如，状态1中的丢包率是1，确是不正确的。（在2态Markov模型中这样描述更为合适）这就导致了在分析丢包突发性时，仅仅停留在连串的丢包，忽略了长时间高丢包密度的影响。然而，这些长时间的高丢包密度，可以显著地影响VoIP服务。 例如，考虑如下的丢包模式 000001100101010110110000000000000000000 正确的Gilbert模型：突发长度 15，突发密度 60% 错误的Gilbert模型：意味着突发长度 1.5bits Markov模型马可夫模型是一种通用的多状态模型，在这种模型中，状态i和j的转换存在着概率p(i, j)。一个2状态的马可夫模型具有一些优势，它可以捕获短期内丢包间的依赖，例如丢包序列[1,4,15,19]。这些通常是非常短的事件（1到3个包长度），但是偶然的链式失败，可以导致长达几十秒的长丢包序列。通过结合2态模型与Gilbert-Elliott模型，可以捕获包括短期连续时间和长期低密度时间。 这种4状态马可夫模型，[7,12]代表爆发期和间隙期。在爆发期中，数据包的接受和丢失，都根据初试的2状态模型。在间隙期中，数据包的接受和丢失，都根据第二个2状态模型。 这些状态有如下定义： 状态1：数据包成功接受 状态2：数据包在一段时间之后接受 状态3：数据包在一段时间后丢失 状态4：孤立的数据包在在一段时期后丢失 例如，采用上面的丢包模式： 丢包模式：000001100101010110110000000000000000000000001000000000 状态： 111113322323232332331111111111111111111111114111111111 将间隙状态的定义和一些标准联系起来，是常用的方法。比如，丢包率低于一些限定，或者连续接受数据包的数量。一个突发事件，一定是一个起于丢包、结束于丢包且中间接受的数据包个数达不到阈值的最长序列,一个非常方便的定义。（对于VoIP来说，这个阈值设定为16是合适的；如果是视频的话，64或者128是合适的取值） 跟踪分析跟踪描述下面的跟踪结果，是哥伦比亚大学、马萨诸塞大学、印度理工学院的研究人员获得的300万个包中的一部分。这些数据通过美国、欧洲、亚洲的不同网站之间进行10ms或30ms间隔的UDP或RTP交流的追踪结果。多数的追踪包含单路延迟和数据包丢失，不过有一部分只有数据包丢失。 跟踪分析有些跟踪，是用上面提到的4状态Markov模型分析的，与此同时，结果解释为一个Gilbert-Elliott模型。这就给出了爆发期和间隙期的长度和丢包密度的定义，爆发期的丢包密度要比间隙期的丢包密度大。 追踪1关于W1的追踪有两个表，第一个表显示的是突发长度与突发权重的散点图。显而易见，超过300个数据包的的突发性事件是存在的，并且典型的损耗密度是25%。并且，在45°对角线上有一些孤立的点，对应着一些由连接失败导致的长段突发性丢包概率。 Figure 3. Trace W1 Scatter diagram of Burst Length vs Weight for packet loss only 第二个图表，显示的是突发长度和突发权重的散点图，但是引入了30ms的抖动缓冲大小。这和图3的单一丢包图分布相近，说明抖动并不是在这个追踪过程中一个非常重要的因素。 Figure 4. Trace W1 Scatter diagram of Burst Length vs Weight for combined packet loss and packet discard (30mS jitter buffer) 追踪3和追踪3相关的图表有2个，第一张图显示的是Gilbert模型下，突发长度和突发权重的散点图。在图中可以清晰地看见超过100长度的突发也发生了，并且具有典型的20-25%的丢包密度。 Figure 4. Trace W3 Scatter diagram of Burst Length vs Weight for packet loss only 第二张表，显示的是在50ms的抖动缓冲下，突发长度和突发权重的散点图。这幅图表明，抖动是追踪中的一个非常显著的问题。突发密度达到500个数据包时，也就意味着突发密度接近30% Figure 5. Trace W3 Scatter diagram of Burst Length vs Weight for packet loss and packet discard (50mS jitter buffer) 影响突发性丢包，对VoIP的通话质量有非常大的影响。即使平均丢包率很小，短时间内的大量丢包也会导致通话质量的下降 总结这篇文章对数据包丢失分布进行了深入的介绍，并显示出数据包丢失和数据包丢弃是自然的突发事件。并且，突发性丢包是稀疏分布而不是集中分布的。典型的突发丢包具有20-30%的丢包密度，时间长达几秒，而连续丢包可能会在极小概率的状态下发生。","tags":[{"name":"VoIP","slug":"voip","permalink":"http://www.xuxinting.cn/tags/voip/"},{"name":"丢包模型","slug":"丢包模型","permalink":"http://www.xuxinting.cn/tags/%E4%B8%A2%E5%8C%85%E6%A8%A1%E5%9E%8B/"}]},{"title":"MySQL Error2003(111) 问题解决","date":"2017-08-24T01:35:05.000Z","path":"2017/08/24/2017-08-24-A-MySQL-Connect-Error/","text":"问题描述MySQL服务器运行在内网的一台独立机器上，在其他机器上进行MySQLdb连接的时候出现： 1_mysql_exceptions.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;10.108.xxx.xxx&apos; (111)&quot;) 连接方式为Python3 的 MySQLdb包 MySQL版本： 15.7.19-0ubuntu0.16.04.1 问题排查首先考虑到MySQL服务器没有进行网关的配置，怀疑是网关拦截了连接。 在网关关闭后，发现还是抛出这个错误，开始Google该问题代码。 经确认，是MySQL服务默认监听地址有问题。在默认配置下，MySQL会监听127.0.0.1本地IP，如果外部主机尝试进行连接则不被处理 问题解决修改MySQL服务器的配置文件，注释掉监听IP配置 配置文件路径： 1/etc/mysql/mysql.conf.d/mysqld.cnf [mysqld] 组中，有一条配置 bind-address = 127.0.0.1 将该条注释掉，然后重启MySQL服务，即可正常连接","tags":[{"name":"MySQL","slug":"mysql","permalink":"http://www.xuxinting.cn/tags/mysql/"}]},{"title":"2017暑期学校——历史","date":"2017-08-23T07:37:30.000Z","path":"2017/08/23/2017-08-23-About-IRC-VCSS-2017-2/","text":"海军博物馆青岛不仅仅是中国第一艘航母“辽宁”舰的母港，也是09年海上阅兵的举行海域。在栈桥的西边，就是新中国海军白手起家的见证————“海军博物馆”。 海军博物馆的规模和建筑，和军博、国博等国家级博物馆比起来，实在寒酸不少。不过因为海军博物馆是由海军建造维护，资金来源和运营上就不是那么细腻。老式的水上飞机和轰炸机就露天摆放，军舰也是一律用白漆保护，看起来萧瑟不少。 不过，新的海军博物馆正在建造中，也许建成以后，也能有军博那样的还原度吧。（不得不说，军博的设备养护真的是非常棒，至少外表上╮(╯▽╰)╭） 进入大门，沿着侧边小道，首先看到的是两枚巨大的螺旋桨。不过明显是展示用的样品，桨尖的空蚀都没有，略微缺少些历史的味道。如果放置从退役的军舰上拆下螺旋桨，将会有更浓重的历史感。 武器海军博物馆现有的馆藏武器主要是三艘军舰、一艘潜艇、一些舰载武器和部分退役飞机。 军舰 鞍山舰，是中国最早的驱逐舰，隶属6607型（鞍山级）。101号鞍山舰是该系首舰，1941年9月4日建成，1954年10月14日在青岛交付中国海军，1969年5月，改装成导弹驱逐舰，1992年4月24日退役。鞍山舰曾参加过第二次世界大战，后据中苏协议，即将退役的鞍山舰被出售给中国，曾经的“四大金刚”首舰。鞍山舰在中国海军的服役时间长达38年，还不包括在苏联海军服役的时间。现在看来，鞍山舰不仅老旧，性能也十分平庸，可在50年代，这是中国海军能够买到的最好军舰了。 济南舰，051型驱逐舰首舰，是驱逐舰国产化的实验品。从最初的6607型仿制舰，到具备飞行甲板的导弹驱逐舰，再到新武器的实验平台。中国海军的发展是及其不易的，济南舰上的钢板都是修修补补的，各处焊接点也是参差不齐。甚至舰内的电子设备也近乎于0，通讯还要靠喊。而现在的055大驱，052D，054A，056，组成了一个驱逐舰家族，曾经的老舰也真的老了。 离开的时候，我还开玩笑说，这个码头上还有几个位置，说不定就是为“辽宁舰”准备的，这又有谁能预料呢？ 潜艇 2017年，海军博物馆引进的新“装备”，就包括新中国第一艘核潜艇“长征1号”，是汉级（091型）核潜艇的首舰，编号401。401号核潜艇服役时便被部署在青岛基地，隶属北海舰队，也是她的最后容身之所。从74年服役，到03年退役，这位29年的老兵，支撑了发展中的中国的海权。 反舰导弹 巨浪-1潜射弹道导弹，是中国第一种使用固体燃料的弹道导弹，搭配092型核潜艇，是核三位一体的组成力量。当遭受核攻击时，游弋在大洋深处的核潜艇，可以发射载有核弹头的弹道导弹进行反击。 可惜的是，现在海军博物馆的装备维护实在是太差了，全部露天摆放，还被杂草攀附。希望当其修缮一新的时候，能够像军博那样，给这些前一辈科研人员的心血一个合适的归处。 其他武器其他的诸如气垫船、鱼雷艇等转杯还在岸上堆着。甚至于还有一艘木壳鱼雷艇，能够保存到现在也是不可思议。如果仔细观察的话，可以看见一些舰艇的螺旋桨上的空蚀，也许是型号难以匹配，没有进行更换。海航的一些老爷机，比如水上飞机、八爷等，估计也受不了多久青岛海风的侵蚀，早晚会报废掉。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.xuxinting.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2017暑期学校——及时行乐","date":"2017-08-23T07:37:30.000Z","path":"2017/08/23/2017-08-23-About-IRC-VCSS-2017-3/","text":"海洋海洋和人类的关系，难以用一句话说清楚。但对于来自非沿海城市的孩子，大海还是保留着一份神秘。 来到青岛，给人的第一感觉，是潮湿。嘲弄海边吹来的海风，在城市中形成了片片云雾，不管是山还是高楼，仿佛直入天际，产生一种虚幻的感觉。 也许已经好久没来到海边了，从海水浴场到野海滩，等着时间一点点流逝，有种让人难舍难分的感觉。 在青岛奥帆中心，看过千帆林立，感受着从大海吹来的“海鲜味”海风，给人一种错觉：也许，该归隐了。从奥帆中心的海边向东，穿过一个人行步道，便来到了一处原味的海滩。 虽然没有梦幻般的沙滩，只有林立的巨石，却让我们度过了几个愉快的下午。 从退潮后的小水洼里，搜寻几只敏捷的螃蟹，在岩缝中，抠出几枚淡菜，在岩壁上偶然捉到几只寄居蟹。孩童般的体验，即使不再年少，也是难以抗拒。 海景因为此次暑期学校安排在崂山区，离石老人海水浴场不过两公里，步行去石老人是一个非常享受的活动。 石老人海水浴场处于海岸线的凹处，来自海洋的潮湿空气和杨柳在这里汇聚。从我们住的地方，可以经常看见不远处的山头上缭绕的水汽。甚至在降雨的日子，可以看见整座山都被水雾笼罩，或许，始皇帝追求的仙境也不过如此吧。 在奥帆博物馆，看着远处的的高楼，耸入云霄以另一种形态展现出来。实在难以想象，楼顶的那些员工在看向地面时又怎样的感受。 看各种样式的帆船出海","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.xuxinting.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2017暑期学校——遇见大牛","date":"2017-08-23T07:37:30.000Z","path":"2017/08/23/2017-08-23-About-IRC-VCSS-2017-4/","text":"大牛Daniel Cohen-or 刘利刚 陈宝权 遇见陈保权教授作为“可视计算”暑期学校的发起人，在活动之初，便和大家见了面。陈教授虽然已经40多岁，但从精神不输我们这些二十多岁的人。不论是工作的激情，还是对学生的照顾，总是亲力亲为。当活动早已结束，山东大学IRC开始工作时，陈教授还会聆听每位同学的暑期收获，并对接下来的生活进行指导。这和某些对学生不太友好的教授时截然不同的。 陈教授带领的山东大学交叉研究中心，和Daniel教授所在的以色列特拉维夫大学、北京电影学院高精尖影像中心，具有非常深入的合作。在SIGGRAPH等会议上投出的文章中，很多都是几人联合署名。也难怪，像这种高水平的论文，普通的教授一年出两三篇就已经非常不易了，而他们能够达到这种规模的学术成果，离不开几方人员的努力。科学没有国界，和值得信赖的人一起进行科学研究，应该是一种非常幸福的事情吧。 Daniel教授给我们讲的是一种新奇的3维扫描方法，不用传统的光学仪器，而是利用液体填充的方法，进行可浸润物体的三维重建。当我们了解到该论文的主要工作后，真的是暗暗感叹，原来技术和科学还能这么用。当然，实验数据的产生，也离不开深圳研究院同学的帮助。传统的光学扫描方法，对物体表面的还原具有较好的方法，但是如果物体内部具有孔洞，将会影响光线的反射，导致最终产生的模型出现严重的偏差。比如说，希腊帕特农神庙的模型，因为具有很多的柱形结构，在中间围成了一片空腔，光学扫描会受到对侧石柱的影响产生错误。而通过调整浸润角度，还原得到的三维模型，不仅能够还原这种结构，还可以还原内部光线不可达区域的结构，具有非常好的还原效果。 刘利刚教授是我们实验室的同学都比较熟悉的，因为曾经是我们老师的老师，所以被我们私下称之为“师爷”。刘利刚教授和陈保权教授的区别是，陈老师看上去是那种精干的的体型，而刘老师一眼看过去有一种非常亲近的感觉。在我们烧烤晚宴的时候，我们和刘老师短暂交谈了一会儿，他对学生完全没有架子，并且对未来充满希望。在几天的报告中，刘老师几乎对每一个讲者都提出了“尖锐”的问题，搞得会场组织者都有点儿不好意思。但刘老师私下又和学者们不断交流，仿佛完全不受之前的影响，这种主动的参与精神十分难得。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.xuxinting.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2017可视计算暑期学校——感触","date":"2017-08-23T07:37:30.000Z","path":"2017/08/23/2017-08-23-About-IRC-VCSS-2017-5/","text":"2017山东大学“可视计算”暑期学校2017年4月，当我还没有决定读研的方向时，在张磊老师的推荐下，报名参加了山东大学交叉研究院的第三届“可视计算”暑期学校。虽然这个暑期学校的目的，主要以吸引即将保研的本科生为主，但毕竟假期也没多少事儿，还可以见识一下学术界、企业界的大牛，何乐而不为呢？ 在之前的宣传材料中，我看到了中科大的刘利刚教授，他是我本科班主任的老师，也是当时我们实验室称之为“师爷”的牛人。还有商汤科技的CEO徐立博士，因为之前的一些技术方向上的重叠，我浏览过商汤科技的主页，被这家公司的深厚技术底蕴所“震撼”。究竟是一群怎样的计算机行业从业者，才能实现如此繁华的成果！ 虽然，最后我没有选择计算机图形学这个方向，但这几天的所见所感，让我觉得本科四年的生活是那么平淡。 过程 注册 因为我错过了正式的注册时间，只赶上了当天的欢迎晚宴，中间的有些事情就不说了。要感谢我的朋友们帮我领会了暑期学校组织者们准备的物品。 包括：一个带有身份的挂牌，一件由组织方设计的文化T恤，几天的午餐券，一份安排书 听报告 不得不说，不同讲者因为各自的出发点不同，往往会带有偏向性地准备演讲内容。以Paul、Daniel等人为主流的学术交流型，会着重介绍自己最新的研究成果，甚至有些是2017年SIGGRAPH的论文；以刘利刚、徐立等人为主的科普性演讲，对大多数入门者来说可以帮助理清概念，思维接受程度比较高。 在我的观察中，与会的老师更倾向于进行学术交流，了解一下其他人有什么好的想法，甚至会尖锐的提出一些未解决的问题。而对于学生来说，更喜欢那些浅显易懂的内容，尤其是中文演讲内容。虽然大多数同学的英语水平并不差，但因为演讲者的母语差异，总会带有一些口音，再加上图形学相关的专业名词，比考六级要难得多。 美食 虽然，会议主办方拒绝为研究生提供住宿，但是提供了海天酒店（体育中心店）的自助午餐，还有一次烧烤晚宴（然而中午吃太多，晚上吃不下了）。多少也是四星级，在菜品的质量上还是可以的，虽然几天都是重复的( ╯□╰ )。 当然，靠海吃海，自己出去吃海鲜也是少不了的。但毕竟是休渔期，本地的海鲜近乎为0，价格也偏高，感受一下海滨城市的丰富海鲜供应也就罢了。值得一提的，就是青岛原浆，每个排挡都有一个啤酒桶，放着冷藏过的原浆啤酒。第一次出去吃的时候不知道他们有原浆，傻乎乎地要了扎啤，后来再喝到原浆的时候发现原来啤酒的口感也可以有这么大的差距。。。 感触在知乎上随手搜了一下山东大学的“可视计算”，发现回答者都在感叹陈保权老师的能量，可以号召这么多的学术界和工业界大佬，来青岛参加这次活动。我想这和陈老师自身就是业界大佬密不可分，如果这个活动不是山东大学的陈老师举办，而是山东理工大学的A老师（对不起，我乱写的）举办，可能只能请到国内的一些牛人罢了。这种精英的抱团，迸发出的能量远超更多普通人所能。 大学必有大师，也要有包容精神。在现在信息化时代的尾巴，计算机所能做的，不能仅仅局限于方寸的机箱之中。和其他学科结合、和其他技术结合，产生更大的能量。比如刘利刚老师的3D打印和计算机图形学的结合，Daniel的三维重建和机械的结合，产生了非常好的结果。我们应该感受到这一点，计算机已经深深的改变了现代的人类生活，并将更加深刻地影响着未来。理论与技术、科研与工程的结合，才能体现计算机的魅力！ 此外，总有人觉得互联网、人工智能是泡沫，总有一天会因为投资人的退出而没落。但如果计算机和传统行业结合起来，深刻改变着我们的生产、生活方式，将没有人会质疑计算机的作用。信息时代、数据时代、人工智能时代，总归是要服务人的，如果像空中楼阁一样飘渺不可捉摸，被大家抛弃也是必然。","tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.xuxinting.cn/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Python中的MySQLdb操作模式性能分析","date":"2017-08-14T12:35:17.000Z","path":"2017/08/14/2017-08-14-Python-Mysql/","text":"不同的MySQLdb操作方式性能分析要在数据库中插入一条数据，该有哪些操作？ 连接数据库 获取数据库游标 执行SQL语句 提交 关闭数据库连接 然而，在实际的操作中，不可避免涉及到对数据库的多次操作，那么，不同的执行组合到底有什么样的性能表现呢？ 在这里，我设定了几种操作方法，并进行了相关的性能测试，用来判断各自的性能差异。 测试基准数据库中创建一个4字段的表，字段属性均为int(32)，对表进行1000000次插入操作。 每次测试完成后，清空表中数据。 采用Python的**time.process_time()**作为性能评价标准 一：数据库保持连接，频繁commit123456789def form1(): db = MySQLdb.connect(db_url,db_user,db_pass,db_name,charset='utf8') cursor = db.cursor() for i in range (1,1000000): sql = \"INSERT INTO %s.%s VALUES(%d,%d,%d,%d)\" %\\ (db_name,table_name,i,i+1,i-1,i/2) cursor.execute(sql) db.commit() db.close() 在该种方法中，数据库的连接处于保持状态，每次执行插入语句，都会进行commit操作提交修改。 二：数据库保持连接，最后一次commit123456789def form2(): db = MySQLdb.connect(db_url,db_user,db_pass,db_name,charset='utf8') cursor = db.cursor() for i in range (1,1000000): sql = \"INSERT INTO %s.%s VALUES(%d,%d,%d,%d)\" %\\ (db_name,table_name,i,i+1,i-1,i/2) cursor.execute(sql) db.commit() db.close() 该种方法需要保持数据库的连接，但并不是每次执行SQL语句都会进行数据库的提交，而是最后一次提交。 三：在数据库操作前连接，操作完成后关闭123456789def form3(): for i in range (1,1000000): db = MySQLdb.connect(db_url,db_user,db_pass,db_name,charset='utf8') cursor = db.cursor() sql = \"INSERT INTO %s.%s VALUES(%d,%d,%d,%d)\" %\\ (db_name,table_name,i,i+1,i-1,i/2) cursor.execute(sql) db.commit() db.close() 该种方法在在每次数据库操作前均需要建立与数据库的连接，但并不会保持下去，而是在对数据库的操作完成后进行连接释放。当下次再进行数据库操作的时候再创建连接。 测试结果123form1 : 116.677019931form2 : 82.13445935399999form3 : 328.88110945000005 理论上分析，每次对数据库操作都需要建立连接，一定是时间消耗最大的；而最后一次全部提交，一定是时间消耗最少的。 从最后的时间统计中，也体现了这一规律。form3这种每次都进行连接建立的方式，耗费的时间达到了form2的4倍。 而form1这种每次数据库操作都进行提交操作的方式，比form2增加了42%的时间。 但是，这三种方法在不同的场景中有不同的应用意义。 对于数据库服务器连接数量有限制的场景中，采用form1和form2既有可能导致部分终端无法连接到数据库。 对于数据操作敏感的场景，form2这种一次提交的方式极有可能导致失败，需要大范围的数据回滚。 所以，各种方法利弊共存，还是要考虑实际情况来操作。 以上内容均为本人学习过程中的测试和分析，如果有任何问题，欢迎批评指正。","tags":[{"name":"Python","slug":"python","permalink":"http://www.xuxinting.cn/tags/python/"},{"name":"Mysql","slug":"mysql","permalink":"http://www.xuxinting.cn/tags/mysql/"}]},{"title":"RTP头字段参数解析","date":"2017-08-08T04:51:06.000Z","path":"2017/08/08/2017-08-08-RTP-Head-Analysis/","text":"概述最近在做VoLTE的数据包分析，发现了一些现有的资料中描述的不太清楚的地方，现将我的个人感受整理出来，供大家批评指正。 VoLTE是Voice over Long Term Evolution的缩写，也就是基于LTE网络的语音通信方案。因为VoLTE的架构设计非常的复杂，还涉及到基站间链路交换、IPv6地址的分配等等，此处不再详述。 在我们的测试中，采用Samsung A5108移动定制机作为测试终端，TCPDUMP作为抓包工具。得到的结果在WireShark中进行分析。 VoLTE包结构VoLTE的数据包主要分为以下几类： ** 通话控制包 ** ** RTCP-传输控制包 ** ** RTP数据包 ** 通话控制包在拨号和通话建立时，双方会发出一系列ESP协议包，包中包含了主叫、被叫、IP地址、支持的编码格式等等信息。 不过，需要注意的是，在WireShark中，ESP包的内容是不会解析的。而如果我们需要了解双方的IP、电话号码或者所在基站，则需要换一种方式。 用文本编辑器，比如NotePad++或者Edit Plus。取决于抓包文件的大小。如果是小文件，可以用NotePad++打开，但如果文件过大，就需要用Edit Plus了。Edit Plus的好处，就是具有64位版本，在数据处理能力上略胜一筹。 在开始，可以看见邀请消息“INVITE”，以及双方的电话信息、IPv6地址、所属网络等身份信息。 在下面的数据中，可以看到不同语音编码方式，这和WireShark分析得到的PT类型是对应的。并且，不同类型的采样频率，是计算RTP时间戳的重要依据。 RTP包结构RTP包是通过UDP协议进行传输的，在UDP的负载中，包含着RTP的数据帧。 version (V): 2 bits This field identifies the version of RTP.The version defined by this specification is two (2). RTP的版本号，1和0有其他定义 padding (P): 1 bit If the padding bit is set, the packet contains one or more additional padding octets at the end which are not part of the payload.The last octet of the padding contains a count of how many padding octets should be ignored, including itself. 是否在包的末尾进行填充，如果进行了填充，则其不属于负载的一部分。用于某些特定的加密算法 extension (X): 1 bit If the extension bit is set, the fixed header MUST be followed by exactly one header extension, with a format defined below. RTP头是否进行了拓展，否则必须按照特定的格式进行。 CSRC count (CC): 4 bits The CSRC count contains the number of CSRC identifiers that follow the fixed header. marker (M): 1 bit The interpretation of the marker is defined by a profile. It is intended to allow significant events such as frame boundaries to be marked in the packet stream. A profile MAY define additional marker bits or specify that there is no marker bit by changing the number of bits in the payload type field. 帧的分隔，接收到带有marker标记的包，意味着一个数据帧的结束。 payload type (PT): 7 bits This field identifies the format of the RTP payload and deand ded de dedeeeand ded de dedee by the application. 如前文提到的数据编码方式，不同的数据类型在此字段有体现。 sequence number: 16 bits The sequence number increments by one for each RTP data packet sent, and may be used by the receiver to detect packet loss and to restore packet sequence. The initial valal vall valvalallhe sequence number SHOULD be random (unpr to make known-plaintext attacks on encryption more difficult, even if the source itself does not encrypt according to the method in Section 9.1, because the packets may flow through a translator that does. 包的序号，每次选用一个随机的数字，防止已知明文攻击。 timestamp: 32 bits The timestamp reflects the sampling instant of the first octet in the RTP data packet. The sampling instant MUST be derived from a clock that increments monotonically and linearly in time to allow synchronization and jitter calculations. RTP头中一个非常重要的字段，可以通过时间戳的变化计算还原一帧的采样时间。 具体的计算方法见下方。 SSRC: 32 bits The SSRC field identifies the synchronization source. This identifier SHOULD be chosen randomly, with the intent that no two synchronization sources within the same RTP session will have the same SSRC identifier. CSRC list: 0 to 15 items, 32 bits each The CSRC list identifies the contributing sources for the payload contained in this packet. The number of identifiers is given by the CC field. RTP时间戳计算因为RTP在传输的过程中，会对一帧数据进行分包，导致不同的数据包具有相同的TimeStamp。在进行时间还原时，必须跟踪具有不同时间戳的包才具有还原的意义。 正如之前提到的，RTP Header中的marker代表着一个数据帧的结束，也代表着接下来的数据包将会有不同的TimeStamp值。 因为RTP的时间戳增量是按照采样时间递增的，所以必须要知道此次传输的数据帧格式。在RTP包格式中，提到过PT字段。PT字段代表着RTP包所传输的数据类型，在我们的VoLTE视频测试中，得到的PT值是115。 得到PT值之后，需要对照通话控制包中的格式及帧率的对应关系，用来进一步计算。 以我们的测试为例，对于数据包i和j，具有不同的TimeStamp值Ti和Tj。PT类型115对应的时钟频率为f &#x3D; 90000 Hz，视频帧率为fps &#x3D; 30 fps。 那么，真实的数据帧时间间隔是多少呢？ ΔT ＝ (Ti - Tj) &#x2F; (f &#x2F; fps) * (1 &#x2F; fps) (s) 时间戳的默认递增长度，是时钟频率&#x2F;帧率，但在我们的测试中，发现其递增规律，并不是严格的3000，而是会在一定范围内浮动。通过数学计算，发现：虽然存在浮动，但仍然存在严格的比例，即TimeStamp的3000对应真实的1&#x2F;30秒。","tags":[{"name":"C","slug":"c","permalink":"http://www.xuxinting.cn/tags/c/"},{"name":"VoLTE","slug":"volte","permalink":"http://www.xuxinting.cn/tags/volte/"},{"name":"RTP","slug":"rtp","permalink":"http://www.xuxinting.cn/tags/rtp/"}]},{"title":"一个简单的UDP测试程序","date":"2017-08-05T07:38:41.000Z","path":"2017/08/05/2017-08-05-A-UDP-code/","text":"一个简单的UDP测试程序功能介绍这是一个简单的UDP测试程序，用于UDP数据包的发送、接收测试。 它能干什么？它集成了客户端和服务端两个部分，可以通过命令行的启动参数进行状态转换。 它可以按照一定的时间进行UDP数据包的发送，也可以设定发送的UDP数据包的负载长度，当然也可以设定每一轮发送数据包的数量。此外，服务进程监听的端口号及客户进程发送时的目标端口也是可以设定的。 不过，需要确定的是，发送时的IP地址和端口号必须是可连通的。比如，发送端和接收端的设备应该处于同一个子网中，如果发生跨子网的情况，则无法成功进行数据传送。 代码展示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330#incnclude &lt;stdio.h&gt;#include &lt;getopt.h&gt;#include &lt;stdbool.h&gt;#incle &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt;char *l_opt_arg;char* const short_options = \"c:l:i:srhp:a:y:\";/*struct option&#123; const char *name; int has_arg; int *flag; int val;&#125;;*/struct option long_options[] = &#123;&#123; \"count\", 1, NULL, 'c' &#125;,&#123; \"length\", 1, NULL, 'l' &#125;,&#123; \"interval\", 1, NULL, 'i' &#125;,&#123; \"port\", 1, NULL, 'p' &#125;,&#123; \"ip\", 1, NULL, 'a' &#125;,&#123; \"cycles\", 1, NULL, 'y' &#125;,&#123; \"send\", 0, NULL, 's' &#125;,&#123; \"receive\", 0, NULL, 'r' &#125;,&#123; \"help\", 0, NULL, 'h' &#125;,&#123; 0, 0, 0, 0&#125;&#125;;void printHelp();struct ControlArguments&#123; bool isSend; bool isReceive; int SendCount; //packets to send at one time,only for send option,default 1 int PacketLength; //data length in UDP packet,only for send option,default 100 int Interval; //time between send cycles.default is 20ms,only for send option int Port; //port used for transmit int Cycles; //operation cycles,only for send option,default 10 char IP[15]; //target ip address,only for send option&#125;;void sendUDP(struct ControlArguments * const);void receiveUDP(struct ControlArguments * const);void initControlArguments(struct ControlArguments * const controlArguments)&#123; controlArguments-&gt;isSend = false; controlArguments-&gt;isReceive = false; controlArguments-&gt;SendCount = 1; controlArguments-&gt;PacketLength = 100; controlArguments-&gt;Interval = 20; controlArguments-&gt;Port = 0; controlArguments-&gt;Cycles = 10; controlArguments-&gt;IP[0] = '\\0';&#125;int charPoint2Int(char const * string)&#123; return atoi(string);&#125;int main(int argc, char *argv[])&#123; int c; int index=0; bool argumentOK = true; static struct ControlArguments controlArguments; initControlArguments(&amp;controlArguments); while((c = getopt_long (argc, argv, short_options, long_options, &amp;index)) != -1) &#123; switch (c) &#123; case 's': printf(\"Send\\n\"); controlArguments.isSend = true; break; case 'r': printf(\"Receive\\n\"); controlArguments.isReceive = true; break; case 'c': l_opt_arg = optarg; printf(\"Send Count : %s\\n\", l_opt_arg); controlArguments.SendCount = charPoint2Int(l_opt_arg); break; case 'y': l_opt_arg = optarg; printf(\"Send Cycles : %s\\n\", l_opt_arg); controlArguments.Cycles = charPoint2Int(l_opt_arg); break; case 'l': l_opt_arg = optarg; printf(\"Packet Length : %s\\n\",l_opt_arg); controlArguments.PacketLength = charPoint2Int(l_opt_arg); break; case 'i': l_opt_arg = optarg; printf(\"Interval Time : %s\\n\",l_opt_arg); controlArguments.Interval = charPoint2Int(l_opt_arg); break; case 'h': printHelp(); break; case 'p': l_opt_arg = optarg; printf(\"Chosen Port : %s\\n\",l_opt_arg); controlArguments.Port = charPoint2Int(l_opt_arg); break; case 'a': l_opt_arg = optarg; printf(\"Target IP : %s\\n\",l_opt_arg); strncpy(controlArguments.IP,l_opt_arg,15); break; default: printf(\"Do not match!!!\\n\"); argumentOK = false; &#125; &#125; if(argumentOK)&#123; if(controlArguments.isSend &amp;&amp; !controlArguments.isReceive)&#123; printf(\"choosing send\\n\"); sendUDP(&amp;controlArguments); &#125;else if(controlArguments.isReceive &amp;&amp; !controlArguments.isSend)&#123; printf(\"choosing receive\\n\"); receiveUDP(&amp;controlArguments); &#125;else&#123; printf(\"**************************\\n\"); printf(\"Arguments Error! both send and receive.\\n\"); &#125; &#125;else&#123; printf(\"************************************************\\n\"); printHelp(); &#125; return 0;&#125;void printHelp()&#123; printf(\"Help Menu:\\n Argument reference list:\\n\"); printf(\" -s :send UDP packets.\\n\"); printf(\" -r :receive UDP packets.\\n\"); printf(\" -c --count :packets to send one cycle.default is 1.\\n\"); printf(\" -y --cycles :send cycles.default is 10.\\n\"); printf(\" -l --length :data length in udp packet.default is 100bytes.\\n\"); printf(\" -i --interval :milliseconds between send options.default is 20ms.\\n\"); printf(\" -a --ip :ip address to operate.\\n\"); printf(\" -p --port :port used for UDP socket.\\n\"); printf(\" -h --help :command help.\\n\");&#125;/*Check IP Formatif format error return false;if format check passed return true;argument is the pointer to the IP string.*/bool IPFormatCheck(char * const IP)&#123; printf(\"IP check\\n\"); int ip_length = strlen(IP); bool checkError = false; int count_s = 0; for(int i = 0,interval = 0 ; i &lt; ip_length ; ++ i)&#123; if(IP[i] == '.')&#123; if(interval == 0 || interval &gt; 3)&#123; checkError = true; break; &#125;else&#123; ++ count_s; interval = 0; &#125; &#125;else if(IP[i] &gt;= '0' &amp;&amp; IP[i] &lt;= '9')&#123; ++ interval; &#125;else&#123; checkError = true; break; &#125; &#125; if(count_s != 3)&#123; checkError = true; &#125; return (!checkError);&#125;/*Check Arguments for send Processif check passed return true;if check failed return false;argument is the pointer to struct ControlArguments.*/bool checkSendConfig(struct ControlArguments * const controlArguments)&#123; printf(\"checking arguments.\\n\"); bool returnVaule; char * IP; IP = malloc(sizeof(strlen(controlArguments-&gt;IP)) + 1); strncpy(IP,controlArguments-&gt;IP,15); if(strlen(IP) != 0)&#123; if(IPFormatCheck(IP))&#123; if((controlArguments-&gt;Port == 0) || (controlArguments-&gt;PacketLength == 0))&#123; printf(\"Port:%d Length:%d\\n\",controlArguments-&gt;Port,controlArguments-&gt;PacketLength); printf(\"[Error] : Port or PacketLength Error.\\n\"); returnVaule = false; &#125;else&#123; returnVaule = true; &#125; &#125;else&#123; printf(\"[Error] : IP Error\\n\"); returnVaule = false; &#125; &#125;else&#123; printf(\"[Error] : IP length = 0!\\n\"); returnVaule = false; &#125; free(IP); return returnVaule;&#125;void threadSend(struct ControlArguments * const controlArguments)&#123; printf(\"****************************************\\nSending Thread Start\\n\"); //定义sockfd int sock_cli = socket(AF_INET,SOCK_DGRAM, 0); //定义sockaddr_in struct sockaddr_in servaddr; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(controlArguments-&gt;Port); //服务器端口 servaddr.sin_addr.s_addr = inet_addr(controlArguments-&gt;IP); //服务器ip struct timeval time; //连接服务器，成功返回0，错误返回-1 if (connect(sock_clli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) != 0)&#123; perror(\"connect\"); &#125;else&#123; char *sendbuf = malloc(controlArguments-&gt;PacketLength); for(int i = 0 ; i &lt; controlArguments-&gt;PacketLength - 1 ; i++)&#123; gettimeofday(&amp;time,NULL); int seed = time.tv_usec + i; sendbuf[i] = rand_r(&amp;seed) % 93 + 33; &#125; sendbuf[controlArguments-&gt;PacketLength - 1] = '\\0'; printf(\"buf : %s\\n\",sendbuf); useconds_t sleep_us = (unsigned int)controlArguments-&gt;Interval * 1000; int pack_seq = 0; for(int i = 0 ; i &lt; controlArguments-&gt;Cycles ; ++ i)&#123; for(int j = 0 ; j &lt; controlArguments-&gt;SendCount ; j++)&#123; char *realSend = malloc((strlen(sendbuf) + 20)); if(realSend)&#123; gettimeofday(&amp;time,NULL); sprintf(realSend,\"[%4ld.%06ld][%4d]:%s\",time.tv_sec,time.tv_usec,++pack_seq,sendbuf); if(send(sock_cli, realSend, strlen(realSend),0) &gt; 0)&#123; printf(\"Send Successful\\n\"); &#125; free(realSend); &#125; &#125; usleep(sleep_us); &#125; free(sendbuf);// printf(\"free.\\n\"); &#125; close(sock_cli); printf(\"Sending Thread Finish\\n****************************************\\n\");&#125;void sendUDP(struct ControlArguments * const controlArguments)&#123; if(checkSendConfig(controlArguments))&#123;// pthread_t tid; printf(\"Before Send Thread\\n\");// pthread_create(&amp;tid, NULL, threadSend(controlArguments), NULL);// pthread_tryjoin_np(tid, NULL); threadSend(controlArguments); printf(\"After Send Thread\\n\"); &#125;else&#123; ; &#125;&#125;bool checkReceiveConfig(struct ControlArguments * const controlArguments)&#123; if(controlArguments-&gt;Port == 0)&#123; printf(\"[Error] : Please set Listening port.\\n\"); return false; &#125;else&#123; return true; &#125;&#125;void threadReceive(struct ControlArguments * const controlArguments)&#123; printf(\"****************************************\\nReceiving Thread Start\\n\"); //定义sockfd int server_sockfd = socket(AF_INET,SOCK_DGRAM, 0); static int recive_serial = 0; if(server_sockfd &lt; 0)&#123; perror(\"socket\"); &#125;else&#123; //定义sockaddr_in struct sockaddr_in server_sockaddr; struct sockaddr_in client_addr; memset(&amp;server_sockaddr,0,sizeof(struct sockaddr_in)); server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_port = htons(controlArguments-&gt;Port); server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); //bind，成功返回0，出错返回-1 if(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(server_sockaddr))==-1)&#123; perror(\"bind\"); &#125;else&#123; //客户端套接字 char buffer[1024]; socklen_t length = sizeof(client_addr); int recv_len = 0; struct timeval time; while(1)&#123; //成功返回非负描述字，出错返回-1 recv_len = recvfrom(server_sockfd,buffer,sizeof(buffer),0,(struct sockaddr *)&amp;client_addr,&amp;length); gettimeofday(&amp;time,NULL); if(recv_len &gt;= 0)&#123; ++ recive_serial; printf(\"[%8ld.%06ld]Get[%d][l:%d] : %s\\n\",time.tv_sec,time.tv_usec,recive_serial,recv_len,buffer); &#125; memset(&amp;buffer,0,sizeof(buffer)); &#125; &#125; &#125; close(server_sockfd); printf(\"Receiving Thread Finish\\n****************************************\\n\");&#125;void receiveUDP(struct ControlArguments * const controlArguments)&#123; if(checkReceiveConfig(controlArguments))&#123;// pthread_t tid; printf(\"Before Thread\\n\");// pthread_create(&amp;tid, NULL, threadReceive(controlArguments), NULL);// pthread_tryjoin_np(tid, NULL); threadReceive(controlArguments); printf(\"After Thread\\n\"); &#125;else&#123; ; &#125;&#125; 函数解析1.main(int argc, char *argv[])int main(int argc, char *argv[]) 主函数，用于接收参数和命令行解析。采用了getopt.h中提供的参数解析功能。可以像Linux自带的命令工具一样，可以通过短参或长参进行运行时的参数设定。 采用的参数设定方式可以调用短参数－ｈ进行查看。默认的参数设定方式如下： -s :send UDP packets. -r :receive UDP packets. -c --count :packets to send one cycle.default is 1. -y --cycles :send cycles.default is 10. -l --length :data length in udp packet.default is 100bytes. -i --interval :milliseconds between send options.default is 20ms. -a --ip :ip address to operate. -p --port :port used for UDP socket. -h --help :command help. 2．IPFormatCheck(char * const IP)bool IPFormatCheck(char * const IP) IP格式检查函数，传入的参数是输入的IP字符串，返回的是检查结果。如果IP字符串符合IP的书写格式，返回true；如果IP字符串出现错误，返回false。 该检查函数仅面向IPv4，如果输入的地址是IPv6，将返回false。 3．checkSendConfig(struct ControlArguments * const controlArguments)bool checkSendConfig(struct ControlArguments * const controlArguments) 发送参数检查，传入的参数是ControlArguments结构体指针，如果参数完备，返回true；如果参数出现冲突或者错误，返回false。 检查过程中，需要检查设定的IP地址，目标端口地址。如果任何一个参数出现错误，将返回false。 4．checkReceiveConfig(struct ControlArguments * const controlArguments)bool checkReceiveConfig(struct ControlArguments * const controlArguments) 监听参数检查，因为监听的是本地端口，所以只要本地端口号不为空即可。 传入的参数是ControlArguments结构体指针，返回值为true或者false。 5．threadSend(struct ControlArguments * const controlArguments)void threadSend(struct ControlArguments * const controlArguments) UDP数据包发送函数，可以作为单独的线程运行。传入的参数为ControlArguments结构体指针，根据设定的发送轮次和间隔、计数进行一次发送过程。 在UDP的数据负载设定中，采用了随机填充的方法，通过随机数到ASCII码的映射，实现定长负载的内容生成。 6．threadReceive(struct ControlArguments * const controlArguments)void threadReceive(struct ControlArguments * const controlArguments) socket处于轮询等待的状态，不断从缓冲区中读取数据包。在接收到数据包后，根据当前的时间添加接收时间戳，用于传输的评估。 7．sendUDP(struct ControlArguments * const controlArguments)void sendUDP(struct ControlArguments * const controlArguments) 该函数用于调用threadSend函数，在具备pthread支持的环境中，可以将发送线程作为子线程处理。因为此处不具备多线程优化的意义，所以暂时将相关功能屏蔽。 8．receiveUDP(struct ControlArguments * const controlArguments)void receiveUDP(struct ControlArguments * const controlArguments) 该函数用于调用threadReceive函数，代码中设计使用pthread进行子线程处理，因为此处多线程效果有限，相关功能暂时屏蔽。","tags":[{"name":"Linux","slug":"linux","permalink":"http://www.xuxinting.cn/tags/linux/"},{"name":"C","slug":"c","permalink":"http://www.xuxinting.cn/tags/c/"},{"name":"UDP","slug":"udp","permalink":"http://www.xuxinting.cn/tags/udp/"}]}]}